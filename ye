-- background_nfv2.lua
-- Plays NFV2 (binary) video-only file with per-frame palettes (correct colors).
-- Usage:
--   lua background_nfv2.lua right
-- (monitor side required unless you use peripheral.find)

local args = {...}
local FILE = "vid_30s.nfv"
local SIDE = args[1]

local function getMonitor()
  if SIDE then
    local m = peripheral.wrap(SIDE)
    if not m then error("No peripheral on side: "..tostring(SIDE)) end
    return m
  end
  local m = peripheral.find("monitor")
  if not m then error("No monitor found. Run: lua background_nfv2.lua <side>") end
  return m
end

local mon = getMonitor()

local TEXT_SCALE = 0.5
local LOOP = true
local PALETTE_CACHE = true -- skip palette updates if identical

-- ---- binary reads ----
local function readU8(h)
  local b = h.read()
  if b == nil then return nil end
  return b
end

local function readU16(h)
  local b1 = readU8(h); local b2 = readU8(h)
  if not b2 then return nil end
  return b1 + b2 * 256
end

local function readU32(h)
  local b1 = readU8(h); local b2 = readU8(h); local b3 = readU8(h); local b4 = readU8(h)
  if not b4 then return nil end
  return b1 + b2*256 + b3*65536 + b4*16777216
end

local function readExact(h, n)
  local s = h.read(n)
  if not s or #s ~= n then return nil end
  return s
end

-- ---- RLE decode ----
local function rleDecode(data)
  local out = {}
  local i = 1
  local n = #data
  while i <= n do
    local run = data:byte(i)
    local val = data:byte(i+1)
    i = i + 2
    out[#out+1] = string.rep(string.char(val), run)
  end
  return table.concat(out)
end

local HEX = "0123456789abcdef"

local function unpack4bppToBgRows(packed, w, h)
  local rows = {}
  local bytePos = 1
  local useHi = true

  for y=1,h do
    local row = {}
    for x=1,w do
      local b = packed:byte(bytePos)
      local nib
      if useHi then
        nib = (b >> 4) & 0x0F
        useHi = false
      else
        nib = b & 0x0F
        useHi = true
        bytePos = bytePos + 1
      end
      row[#row+1] = HEX:sub(nib+1, nib+1)
    end
    if not useHi then
      useHi = true
      bytePos = bytePos + 1
    end
    rows[y] = table.concat(row)
  end

  return rows
end

local function setPalette(palBytes)
  for i=0,15 do
    local r = palBytes:byte(i*3 + 1) / 255
    local g = palBytes:byte(i*3 + 2) / 255
    local b = palBytes:byte(i*3 + 3) / 255
    local mask = 2^i
    if mon.setPaletteColour then
      mon.setPaletteColour(mask, r, g, b)
    else
      mon.setPaletteColor(mask, r, g, b)
    end
  end
end

local function waitTimer(id)
  while true do
    local e, tid = os.pullEvent()
    if e == "timer" and tid == id then return end
  end
end

local function playOnce()
  local h = fs.open(FILE, "rb")
  if not h then error("Can't open "..FILE) end

  local magic = readExact(h, 4)
  if magic ~= "NFV2" then h.close(); error("Bad magic, expected NFV2") end

  local ver = readU8(h)
  local flags = readU8(h)
  local w = readU16(h)
  local hh = readU16(h)
  local fps1000 = readU32(h)
  local frames = readU32(h)

  local fps = fps1000 / 1000
  local dt = 1 / fps
  local useRLE = (flags & 0x01) == 0x01

  if mon.setTextScale then pcall(function() mon.setTextScale(TEXT_SCALE) end) end
  mon.setCursorBlink(false)
  mon.setBackgroundColor(colors.black)
  mon.clear()

  local textRow = string.rep(" ", w)
  local fgRow = string.rep("0", w)

  local lastPal = nil
  local timerId = os.startTimer(0)

  for i=1,frames do
    local palLen = readU16(h)
    if not palLen then break end
    local palBytes = readExact(h, palLen)
    local dataLen = readU32(h)
    local data = readExact(h, dataLen)

    if (not PALETTE_CACHE) or (not lastPal) or (palBytes ~= lastPal) then
      setPalette(palBytes)
      lastPal = palBytes
    end

    local packed = data
    if useRLE then packed = rleDecode(data) end

    local bgRows = unpack4bppToBgRows(packed, w, hh)
    for y=1,hh do
      mon.setCursorPos(1, y)
      mon.blit(textRow, fgRow, bgRows[y])
    end

    waitTimer(timerId)
    timerId = os.startTimer(dt)
  end

  h.close()
end

while true do
  playOnce()
  if not LOOP then break end
end
